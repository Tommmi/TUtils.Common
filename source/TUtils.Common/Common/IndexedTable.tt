<#@
template debug="true" hostSpecific="true" #><#@ 
output extension=".cs" #><#@ 
Assembly Name="System.Core" #><#@ 
Assembly Name="System.Windows.Forms" #><#@ 
Assembly Name="System.Xml.Linq" #><#@ 
include file="TemplateFileManager.CS.ttinclude" #><#@ 
include file="THelper.ttinclude" #><#@ 
import namespace="System" #><#@ 
import namespace="System.IO" #><#@ 
import namespace="System.Diagnostics" #><#@ 
import namespace="System.Collections" #><#@ 
import namespace="System.Collections.Generic" 
#>/**************** 
    autogenerated
****************/
using System;
using System.Collections.Generic;
using System.Linq;

// ReSharper disable UnusedMember.Global

namespace TUtils.Common
{
<#
	IndexedTableGenerator generator = new IndexedTableGenerator(this);
	generator.WriteIndexedTableClass(2);
	generator.WriteIndexedTableClass(3);
	generator.WriteIndexedTableClass(4);
	generator.WriteIndexedTableClass(5);
	generator.WriteIndexedTableClass(6);
	generator.WriteIndexedTableClass(7);
#>
}
 
<#+



public class IndexedTableGenerator
{
	string tempText = "";

	GeneratedTextTransformation _host;

	public IndexedTableGenerator(
		GeneratedTextTransformation thisHost)
	{
		_host = thisHost;
	}


	// #################################################################
	public void BeginWrite()
	{
		tempText = "";
	}
					
	// #################################################################
	public void Write(string outText)
	{
		_host.Write(outText);
	}

	// #################################################################
	public string EndWrite(string ident)
	{
		string res = "";
		string[] lines = tempText.Split(new char[] { '\n' });
		foreach(var line in lines)
			res += ident + line + '\n';
		return res.Remove(res.Length-1);
	}

	public void WriteIndexedTableClass(int countCols)
	{
		var T1_T2 = "";
		for(int i=0; i< countCols; i++)
		{
			if ( i!=0)
				T1_T2 += ", ";
			T1_T2 += "T";
			T1_T2 += (i+1);
		}

#>
	/// <summary>
	/// A set of tuples, that provides performance optimized Find-methods to it's values.
	/// With "IndexedTable" you needn't waste time in programming dictionaries for 
	/// fast access to values by different keys. "IndexedTable" will care for instantiating such
	/// dictionaries on-the-fly. It will also keep them up to date. Do you want to use a compound
	/// key ? Don't worry. "IndexedTable" will use coumpound hash keys automatically if neccessary.
	/// </summary>
	/// <remarks>
	/// <example>
	/// Guess you have an in-memory set of workshop registrations. One student may be registrated for 
	/// several workshops. One workshop normally have several students.
	/// <code><![CDATA[
	/// var registrations = new IndexedTable<Student,Workshop>();
	/// registrations.Insert(new Tuple<Student,Workshop>(student1, workshop1));
	/// registrations.Insert(new Tuple<Student,Workshop>(student1, workshop2));
	/// registrations.Insert(new Tuple<Student,Workshop>(student2, workshop1));
	/// registrations.Insert(new Tuple<Student,Workshop>(student2, workshop3));
	/// registrations.Insert(new Tuple<Student,Workshop>(student3, workshop1));
	/// ]]></code>
	/// Guess now you want to find all fellows of student2 without iterating slowly through all registrations.
	/// So you need to look fast for all workshops of student2 and after that fast for all students in these workshops.
	/// Normally you would have to program two hash maps and keep them up-to-date for every insert of a registration.
	/// With IndexedTable you have to write only the following:
	/// <code><![CDATA[
	/// IEnumerable<Student> fellows = registrations
	/// 	.FindByItem1(student2)
	/// 	.Select(t => t.Item2) // workshop
	/// 	.SelectMany(workshop => registrations.FindByItem2(workshop))
	/// 	.Select(t => t.Item1)
	///		.Where(student=>student != student2)
	///		.Distinct(); // ==> student1
	/// ]]></code>
	/// 
	/// </example>
	/// </remarks>
	public class IndexedTable<<#=T1_T2#>> : IndexedTableBase
	{
		public IndexedTable()
		{
			Init(<#=countCols#>);
		}

		private static object[] Convert(Tuple<<#=T1_T2#>> value)
		{
			return new object[] { <#+
		
		for(int i=0; i< countCols; i++)
		{
			if ( i!=0)
			{
				#>, <#+
			}
			#>value.Item<#=i+1#><#+
		}
		
		#> };
		}

		private Tuple<<#=T1_T2#>> Convert(object[] value)
		{
			return new Tuple<<#=T1_T2#>>(<#+
		
		var valueParams = "";
		for(int i=0; i< countCols; i++)
		{
			if ( i!=0)
				valueParams += ", ";
			valueParams += "(T" + (i+1) +")value["+i+"]";
		}
			#><#=valueParams#>);
		}

		/// <summary>
		/// Creates a database-like index to some columns of this Tuple-set
		/// </summary>
		public void AddIndex(<#+
		for(int i=0; i< countCols; i++)
		{
			if ( i!=0 )
			{
				#>, <#+
			}
			#>bool useItem<#=i+1#>ForIndex<#+
		}
			#>)
		{
			var indexedColumnNumbers = new List<int>();

			<#+
		for(int i=0; i< countCols; i++)
		{
			#>if (useItem<#=i+1#>ForIndex)
				indexedColumnNumbers.Add(<#=i#>);

			<#+
		}

			#>EnsureIndex(indexedColumnNumbers.ToArray());
		}

		/// <summary>
		/// Inserts row to the table
		/// </summary>
		/// <param name="value"></param>
		public void Insert(Tuple<<#=T1_T2#>> value)
		{
			InsertValue(Convert(value));
		}

		#region find

		<#+
		var startPermutation = new List<int>();

		foreach(var permutation in GetPermutation(startPermutation, 1, countCols))
		{
			var keysCount = permutation.Count;
			if ( keysCount == 0 || keysCount == countCols )
				continue;

		#>/// <summary>
		/// Finds all rows matching the passed values
		/// </summary>
		public IEnumerable<Tuple<<#=T1_T2#>>> FindByItem<#+
			for(int i=0; i< keysCount; i++)
			{
				if ( i!=0 )
				{
					#>_<#+
				}
				#><#=permutation[i]#><#+
			}
					#>(<#+
			for(int i=0; i< keysCount; i++)
			{
				if ( i!=0 )
				{
					#>, <#+
				}
				#>T<#=permutation[i]#> val<#=permutation[i]#><#+
			}
		#>)
		{
			return Find(new object[] { <#+
			for(int i=0; i< countCols; i++)
			{
				if ( i!=0 )
				{
					#>, <#+
				}
				if ( permutation.Any(k=>k==i+1) )
				{
					#>val<#=i+1#><#+
				}
				else
				{
					#>null<#+
				}
			}
			#> }).Select(Convert).ToList();
		}
		<#+
		}
		#>

		#endregion

		#region remove

		/// <summary>
		/// Removes row from table
		/// </summary>
		/// <param name="value"></param>
		public void Remove(Tuple<<#=T1_T2#>> value)
		{
			RemoveValue(Convert(value));
		}

		<#+

		foreach(var permutation in GetPermutation(startPermutation, 1, countCols))
		{
			var keysCount = permutation.Count;
			if ( keysCount == 0 || keysCount == countCols )
				continue;

		#>/// <summary>
		/// Removes all rows matching the passed row item
		/// </summary>
		public void RemoveAllMatchingItem<#+
			for(int i=0; i< keysCount; i++)
			{
				if ( i!=0 )
				{
					#>_<#+
				}
				#><#=permutation[i]#><#+
			}
			#>(<#+
			for(int i=0; i< keysCount; i++)
			{
				if ( i!=0 )
				{
					#>, <#+
				}
				#>T<#=permutation[i]#> val<#=permutation[i]#><#+
			}
		#>)
		{
			RemoveAllBy(new object[] { <#+
			for(int i=0; i< countCols; i++)
			{
				if ( i!=0 )
				{
					#>, <#+
				}
				if ( permutation.Any(k=>k==i+1) )
				{
					#>val<#=i+1#><#+
				}
				else
				{
					#>null<#+
				}
			}
			
			#>});
		}
		<#+
		}

		#>
		
		#endregion

		/// <summary>
		/// gets all rows
		/// </summary>
		public new IEnumerable<Tuple<<#=T1_T2#>>> GetAllRows()
		{
			return base.GetAllRows().Select(Convert).ToList();
		}

		/// <summary>
		/// returns true, if row exists
		/// </summary>
		public bool Exists(<#+
		for(int i=0; i< countCols; i++)
		{
			if ( i!=0 )
			{
				#>, <#+
			}
			#>T<#=i+1#> val<#=i+1#><#+
		}
		
		#>)
		{
			return Find(new object[] { <#+
		for(int i=0; i< countCols; i++)
		{
			if ( i!=0 )
			{
				#>, <#+
			}
			#>val<#=i+1#><#+
		}
		
		#> }).Select(Convert).ToList().Any();
		}
	}

<#+
	}

	private List<List<int>> GetPermutation(List<int> currentPermutation, int startColNb, int endColNb)
	{
		var permutations = new List<List<int>>();
		permutations.Add(currentPermutation);

		for (int i=startColNb; i<=endColNb; i++)
		{
			var newPermutation = new List<int>();
			newPermutation.AddRange(currentPermutation);
			newPermutation.Add(i);
			permutations.AddRange(GetPermutation(newPermutation,i+1,endColNb));
		}

		return permutations;
	}
}



#>